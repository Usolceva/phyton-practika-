# Создайте словать заданный по формуле 3*n+1, где n это ключ, а формула значение  Для n = 6: {1: 4, 2: 7, 3: 10, 4: 13, 5: 16, 6: 19}
# my_dict = {}
# number = int(input('введите число: '))
# for n in range (1, number+1):
#     my_dict[n] = 3*n+1 #запись словаря идет через квадратные скобки
#     print(my_dict)
# #а обращение через get
# my_dict.get(3) #получаем какое-то конкретное значение словаря обратившись  по ключу 3
# #методы для работы со строками
#my_string = 'питон самый лучший'
#my_string = my_string.split('и')  # split распиливает стороку по заданному элементу удаляя его, обязательно нужно перепресвоить название тоже или новая переменная
#print(my_string)# ответ: ['п', 'тон самый лучш', 'й']
# my_string = my_string.replace('и', '$') #находит символ и заменяет его на новый
# print(my_string)# ответ:п$тон самый лучш$й
# print(my_string.startswith('пит')) #не нужно присваевать сразу вывод ответы в стиле (тру или фолс)если пит то тру если нет то фолс
# print(my_string.lower().startswith('пит'))#переводит строку в нижний регистр но не изменяет ее только проверяет
# print(my_string.endswith('ире')) #сторока заканчивается проверяет на ире 
# my_string = '   питон самый лучший\n'
# print(my_string.strip()) #отрезает не нужные пробелы и символы не изменяет поэтому нужно переприсвоить (rstrip - отрезает справа) (lstrip - отрезает с лева)
# my_list = ['1','2','34','5','6','7','8']
# print(' '.join(my_list)) #строка склеиная через пробел: 1 2 34 5 6 7 8

#Найдите корни квадратного уравнения Ax² + Bx + C = 0 с помощью математических формул нахождения корней квадратного уравнения
# equation = '3*x**2 + 5*x - 6 = 0'

# Напишите программу, которая принимает на вход строку,
# и отслеживает, сколько раз каждый символ уже встречался.
# Количество повторов добавляется к символам с помощью постфикса формата _n.
# пример:
# d g h t r g r h t j h b v f d s d f
# выход:
# d g h t r g_2 r_2 h_2 t_2 j h_3 b v f d_2 s d_3 f_2

#нужно использовать метод split() для деления строки, этот метод используется для строк
# любой метод заканчивается скобками в них указываем аргументы,  
#в split() пишем в скобках символ по которому будет делится строка 
#это будет пробел (' ')= ()можно в ковычках, а вообще по умолчанию уже пробел заложен в метод

string = 'd g h t r g r h t j h b v f d s d f'

# my_list = string.split() # из сторки переводим в список
# print(my_list) # не обязательно , можно убрать, добавлено для наглядности

# my_dict = {} #обьявляем пустой словарь, буквы будут ключами, а значения это сколько раз буква повторяется

# for letter in my_list: # letter(буква) = это будет наш ключ
#     my_dict[letter] = my_dict.get(letter, 0) + 1 # обращаемся к словарю по определенному ключу если этот ключ есть 
# #то он перезапишет существующий это значение, если этого ключа нет то он создаст новый ключ  в словарь записываем ключ
# #наш словарь пустой, говорим дай ключ по [d], 
# #словарь говорит у меня его нет и выдаст NONE НО ВМЕСТО ЭТОГО ОН ВЫДАСТ 0, 0 +1 = 1, 
# #СООТВЕТСТВЕННО В СЛОВАРЬ ПО КЛЮЧУ [d] ЗАПИШЕТСЯ 1
# #get(получить), мы говорим получи значение по ключу, если у нас его нету ставим 0 и +1 значение будет первым,
# #(тоесть ключ со значением 1 [d_1]), идем дальше ключ [d_1]  
# #у него уже значение 1 есть плюсуем 1 = перезаписывается со значением [d_2]

#     print(my_dict)

# 2 РУШЕНИЕ через список:
# string = 'd g h t r g r h t j h b v f d s d f'
# print(string)
# my_list = string.split() #распилили строку
# my_dict = {}
# new_list = []

# for letter in my_list: 
#      my_dict[letter] = my_dict.get(letter, 0) + 1
#      if my_dict.get(letter) > 1:
#         new_list.append(letter + '_' + str(my_dict.get(letter)))
#      else:
#         new_list.append(letter)
# print(' ' .join(new_list)) #склеивает строку при помощи пробела, без этой команбы будет выдавать все в списке [] 


# Пользователь вводит текст(строка).
# Словом считается последовательность непробельных символов идущих подряд,
# слова разделены одним или большим числом пробелов.
# Определите, сколько различных слов содержится в этом тексте.

# text = input('Введите текст: ')
# print(text) 

# text = text.split() #делим
# print(text) 

# text = set(text) #обращаем во множество
# print(text) 
# print(f'в нашем тексте {len(text)} ууникальных слов(а)')

#  #2 РЕШЕНИЕ, ОПТИМИЗАЦИЯ:
# text = set(input('Введите текст: ').split())
# print(f'в нашем тексте {len(text)} ууникальных слов(а)')

#       3   решение:
# text = input('Введите текст: ')
# text = text.split() # разбиваем
# new_list = [] #берем пустой список
# for word in text:# бежим по словам в тексе
#     if not word in new_list: #если слова нет в списке
#         new_list.append(word) #то добавляем
# print(f'в нашем тексте {len(new_list)} ууникальных слов(а)')

#Дана последовательность чисел. Получить список уникальных элементов заданной последовательности.
# my_list = [1, 2, 3, 4, 9, 4, 2, 10, 1]
# new_list = []
# for item in my_list: #проходимся по элементам списка
#     print(f'{item} встречается {my_list.count(item)}') # чтобы посмотреть как считает вхождения
#     if my_list.count(item) == 1: #если эле-ты списка возвращиются 1 раз(это и будут уникальные значения)
#         new_list.append(item) # то добавляем в наш новый список
# print(my_list)
# print(f'уникальные элементы: {new_list}')

#     2 РЕШЕНИЕ: (назвается лист комприкейшен, это сокращенная форма)
# my_list = [1, 2, 3, 4, 9, 4, 2, 10, 1]
# print([letter for letter in my_list if my_list.count(letter) ==1]) # letter это переменная может называться хоть как
#проходимся по списку и добавляем в наш список letter, но при условие что letter будет входить 1 раз

#     ГЕНЕРАТОР СПИСКА

# new_list = [i for i in range(0, 10, 2)] # генератор списка  от 0 до 10 с шагом 2, шаг можно не ставить, 
# можно сразу писать в принте
# print(new_list)

# new_list = [(i, j) for j in range(5) for i in range (10)] # котежи, можно сразу писать в принте
# print(new_list)
